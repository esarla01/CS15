# HW 3: Binary Search Trees

**Author:** Erin Sarlak  
**Date:** April 6, 2021

## Purpose of the Program

The purpose of this program is to implement a binary search tree (BST) that supports a multiset (also known as a bag), which allows duplicate values to be stored.

## Acknowledgements

I attended office hours on Sunday, where Ellis and Roger provided valuable assistance.

## Files

- **BinarySearchTree.cpp**: Contains the implementation of the `BinarySearchTree` class, including the code for its functions.
- **BinarySearchTree.h**: Contains the definition of the `BinarySearchTree` class.
- **unit_tests.h**: Contains the test code to ensure that the public and private functions of the `BinarySearchTree` class work properly.
- **my_output**: The output generated by my program for HW3.
- **comp_output**: The output generated by the provided HW3 program.

## How to Compile and Run the Program

1. Run the command `make` to compile the program.
2. Run the command `./hw3` to execute the program.

## Testing Strategy

I used **diff testing** and **unit testing** to verify my implementation. For each public function required by the assignment, I created at least one unit test. I included both regular and edge cases in these tests, such as when the tree is empty, has a single node, or contains multiple identical values. 

### Insert Function Testing

I tested the `insert` function with the following cases:
1. Inserting multiple values into an empty tree.
2. Inserting the same value more than once.

### Operator Assignment Testing

I tested the operator assignment (`operator=`) function with these cases:
1. When assigning to an empty tree.
2. When assigning to a non-empty tree.
3. When assigning to a tree that contains duplicate values.

### Remove Function Testing

I thoroughly tested the `remove` function with the following edge cases:
1. Removing from an empty tree.
2. Trying to remove a node that doesnâ€™t exist.
3. Removing a node with no children.
4. Removing a node with one child.
5. Removing a node with two children, where the minimum node in the right subtree has a right child.
6. Removing a node with two children, where the minimum node in the right subtree is a leaf.
7. Removing a node with multiple occurrences.

After carefully testing these cases, I also conducted **diff testing** to compare my output with the provided output. The files `my_output` and `comp_output` show the results of both programs. After adjusting my implementation and running several trials, the outputs matched, confirming that both BST implementations function identically.

## Questions

### 1. Will your implementation of the remove function use the privately defined `find_min()` or `find_max()`? Why?

Yes, it will. When removing a node with two children, I will replace the node with the minimum value from its right subtree and then remove that minimum node. This process requires the `find_min()` function to easily locate the smallest node in the right subtree.

### 2. Is it possible for the privately defined `find_min()` or `find_max()` to return a value that does not point to a valid node? Why or why not?

Yes, it is possible if the tree is empty. In that case, there is no valid node to return. However, within a non-empty subtree, there is always a valid node that represents either the minimum or maximum value.

### 3. If you answered yes to Q2, what value is returned, and when?

- `find_min()` returns the largest possible integer if the tree is empty.
- `find_max()` returns the smallest possible integer if the tree is empty.

### 4. Write pseudocode for your private `find_min()` function.

```text
Base case:
  If the left child of the node is nullptr, return the node (it is the leftmost leaf).

Recursive case:
  Call find_min(node->left) to traverse the left subtree until the bottom left leaf is found.
